`View Hierarchy 视图层级`


> #Understanding Auto Layout

# 理解 Auto Layout

> Auto Layout dynamically calculates the size and position of all the views in your view hierarchy, based on constraints placed on those views. For example, you can constrain a button so that it is horizontally centered with an Image view and so that the button’s top edge always remains 8 points below the image’s bottom. If the image view’s size or position changes, the button’s position automatically adjusts to match.

`Auto Layout` 基于当前**视图层级**中所有 `View` 相关约束，动态地计算所有 `View` 的大小和位置。比如，你可以约束一个 `Button` 让它水平方向上的中点与一个 `Image View` 对齐并且 `Button` 的顶部距离 `Image View` 底部保持 8 `point`。如果 `Image View` 的大小或位置变化，`Button` 的位置会自动调整去满足约束。

> This constraint-based approach to design allows you to build user interfaces that dynamically respond to both internal and external changes.

这种基于约束的设计方法，能够让你构建动态响应`External Changes``Internal Changes`的界面。


> ##External Changes

## 外界变化

> External changes occur when the size or shape of your superview changes. With each change, you must update the layout of your view hierarchy to best use the available space. Here are some common sources of external change:
> The user resizes the window (OS X).
The user enters or leaves Split View on an iPad (iOS).
The device rotates (iOS).
The active call and audio recording bars appear or disappear (iOS).
You want to support different size classes.
You want to support different screen sizes.
Most of these changes can occur at runtime, and they require a dynamic response from your app. Others, like support for different screen sizes, represent the app adapting to different environments. Even through the screen size won’t typically change at runtime, creating an adaptive interface lets your app run equally well on an iPhone 4S, an iPhone 6 Plus, or even an iPad. Auto Layout is also a key component for supporting Slide Over and Split Views on the iPad.

外部变化发生在 `superview`的大小和形状发生变化的时候。随着每次变化，你必须更新 `视图层级`中相关的布局来最好地使用可用空间。

下面是几个常见的外部变化发生的原因：
    
    1. 用户调整了 Window 的大小(MacOS)
    2. 用户在 iPad 进入或者离开了 Split View(iOS)
    3. 设备旋转(iOS)
    4. 通话活跃 音频录制状态栏出现或者消失(iOS)
    5. 支持不同的 size classes
    6. 支持不同的 屏幕尺寸

大多数变化会发生在运行时，这要求 App 能够动态响应。剩下的，比如支持不同尺寸的屏幕，意味着 App 需要适配不同的环境。尽管屏幕大小通常不会变化，构建一个适配性的界面能够让 App 在 iPhone4s、iPhone6 甚至 iPad 上运行效果一致。 在 iPad 上 Auto Layout 也是支持 Sidle Over 和 SpliView的关键部分。

> ##Internal Changes

## 内部变化

> Internal changes occur when the size of the views or controls in your user interface change.

当界面上的 `View` 或 `Control` 的大小发生变化的时候 `内部变化` 发生.


> Here are some common sources of internal change:
The content displayed by the app changes.
The app supports internationalization.
The app supports Dynamic Type (iOS).
When your app’s content changes, the new content may require a different layout than the old. This commonly occurs in apps that display text or images. For example, a news app needs to adjust its layout based on the size of the individual news articles. Similarly, a photo collage must handle a wide range of image sizes and aspect ratios.

下面是一些常见的 `internal change` 发生的情况：

    1. App 改变了展示的内容
    2. App 支持国际化
    3. App 支持 Dynamic Type

当 App 的内容变化的时候， 新的内容可能需要一种不同与之前旧的布局（layout）。这通常发生在 App 展示文字或图片的时候。举个例子， 一个新闻 APP 需要根据每一篇新闻文章调整它的布局。相似地，一个照片拼贴必须hold住各种尺寸、纵横比的图片。

>Internationalization is the process of making your app able to adapt to different languages, regions, and cultures. The layout of an internationalized app must take these differences into account and appear correctly in all the languages and regions that the app supports.

国际化是一项让你的 App 有能力去适配各种语言、地区、文化的工作。国际化的 App 的 layout 必须能够正确处理自己支持的语言、地区在账户和外表上的差异。

>Internationalization has three main effects on layout. First, when you translate your user interface into a different language, the labels require a different amount of space. German, for example, typically requires considerably more space than English. Japanese frequently requires much less.

国际化在 layout 上主要有三个主要的影响。
第一当你把界面翻译成不同语言的时候， labels 要求不同的空间。举个例子，德语，通常比英语要求考虑更多空间，日语则经常要求更少。


>Second, the format used to represent dates and numbers can change from region to region, even if the language does not change. Although these changes are typically more subtle than the language changes, the user interface still needs to adapt to the slight variation in size.

第二，用于表示 日期和数字的格式随着地区的不同也会发生变化，甚至相同语言不同地区有时也不一样。尽管这些变化相比语言的变化相当小，界面仍旧需要去适配尺寸上轻微的变化。

>Third, changing the language can affect not just the size of the text, but the organization of the layout as well. Different languages use different layout directions. English, for example, uses a left-to-right layout direction, and Arabic and Hebrew use a right-to-left layout direction. In general, the order of the user interface elements should match the layout direction. If a button is in the bottom-right corner of the view in English, it should be in the bottom left in Arabic.

第三，语言的干部能够影响的不止文字的大小，还有 layout 的组织关系。不同的语言用不同的 layout 方向。举个例子，英语，使用 `left-to-right` layout 顺序，阿拉伯，希伯来语，用 `right-to-left ` 的布局方向。总的来说，界面上 UI 元素应该与 layout 方向匹配。如果一个 Button 在英语环境下，位于视图的右下角，那么在阿拉伯语环境下，它应该在视图的左下角。

>Finally, if your iOS app supports dynamic type, the user can change the font size used in your app. This can change both the height and the width of any textual elements in your user interface. If the user changes the font size while your app is running, both the fonts and the layout must adapt.

最后，如果你的 iOS App 支持 `dynamic type`， 用户能够改变你App中的字体大小。这能改变界面中所有文字相关的元素。如果用户在App运行的时候，改变了文字大小，字体和 layout 都必须适配。



> ##Auto Layout Versus Frame-Based Layout

## Auto Layout VS 基于 Frame 的布局


> There are three main approaches to laying out a user interface. You can programmatically lay out the user interface, you can use autoresizing masks to automate some of the responses to external change, or you can use Auto Layout.

布局界面有三种主要的方法。用代码布局界面，用 autoresizing masks 去自动响应部分外部变化，或用 Auto Layout

>Traditionally, apps laid out their user interface by programmatically setting the frame for each view in a view hierarchy. The frame defined the view’s origin, height, and width in the superview’s coordinate system.

通常来说， App 布局通过代码设置视图层级中每个 View 的 Frame 来布局界面。 Frame 定义了 View 的原点，宽高在父视图的坐标系中。

![Image one](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/layout_views_2x.png)



>To lay out your user interface, you had to calculate the size and position for every view in your view hierarchy. Then, if a change occurred, you had to recalculate the frame for all the effected views.

为了布局界面，你不得不去计算视图层级中所有 View 的位置和大小。然后如果有一个变化发生，你就得去计算所有受影响 View 的 Frame。

>In many ways, programmatically defining a view’s frame provides the most flexibility and power. When a change occurs, you can literally make any change you want. Yet because you must also manage all the changes yourself, laying out a simple user interface requires a considerable amount of effort to design, debug, and maintain. Creating a truly adaptive user interface increases the difficulty by an order of magnitude.

以编程方式定义一个 View 的 Frame 在很多方面提供了最大的灵活性和功能。当内外部变化发生时，你能够遍历所有层级并随意调整。因为你自己必须管理所有的变化，布局一个简单的界面需要付诸很多努力在 设计、debug、保养上。随着数量级的增加，创建真正意义上的可适配的界面的难度也会随之增加。


>You can use autoresizing masks to help alleviate some of this effort. An autoresizing mask defines how a view’s frame changes when its superview’s frame changes. This simplifies the creation of layouts that adapt to external changes.

使用 `autoresizing masks` 可以帮助化解部分努力。 `autoresizing mask` 定义了 当一个 View 的 superview 的 frame 变化的时候， View 的 frame 如何变化。下面这个最简单的 layouts 适应了 `external changes`


>However, autoresizing masks support a relatively small subset of possible layouts. For complex user interfaces, you typically need to augment the autoresizing masks with your own programmatic changes. Additionally, autoresizing masks adapt only to external changes. They do not support internal changes.

然而，`autoresizing masks` 支持了可能 layouts 的一个相关子集。对于复杂的界面来说，你通常需要在代码里加参数去控制 `autoresizing masks`. 此外，`autoresizing masks` 只适配于 `external changes`. 不支持 `internal changes`.


>Although autoresizing masks are just an iterative improvement on programmatic layouts, Auto Layout represents an entirely new paradigm. Instead of thinking about a view’s frame, you think about its relationships.

尽管 `autoresizing masks` 相比编程方式布局只有一点提升，`Auto Layout` 则是另外一种完全不同的范例。不再思考一个 View 的 frame，而是去思考 View 之间的关系。



>Auto Layout defines your user interface using a series of constraints. Constraints typically represent a relationship between two views. Auto Layout then calculates the size and location of each view based on these constraints. This produces layouts that dynamically respond to both internal and external changes.

`Auto Layout` 定义界面使用一系列的约束。`Constraints` 通常代表了 两个 View 之间的关系。`Auto Layout` 会根据这些约束去计算每个 View 的 大小 和 位置。这就使得 布局能够 动态地响应 内外变化。


>The logic used to design a set of constraints to create specific behaviors is very different from the logic used to write procedural or object-oriented code. Fortunately, mastering Auto Layout is no different from mastering any other programming task. There are two basic steps: First you need to understand the logic behind constraint-based layouts, and then you need to learn the API. You’ve successfully performed these steps when learning other programming tasks. Auto Layout is no exception.

设计约束造成的具体行为的逻辑相比写程序上或面向对象的代码非常不同。幸运的是 掌握 `Auto Layout` 并不比 掌握其他编程技巧难。只有两点基本步骤：第一 要去理解 基于 约束布局其背后的逻辑，然后学习相关API。在学习其他编程你已经成功实践过了。`Auto Layout` 也什么例外。



The rest of this guide is designed to help ease your transition to Auto Layout. [The Auto Layout Without Constraints](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html#//apple_ref/doc/uid/TP40010853-CH8-SW1) chapter describes a high-level abstraction that simplifies the creation of Auto Layout backed user interfaces. The Anatomy of a Constraint chapter provides the background theory you need to understand to successfully interact with Auto Layout on your own. Working with Constraints in Interface Builder describes the tools for designing Auto Layout, and the Programmatically Creating Constraints and Auto Layout Cookbook chapters describe the API in detail. Finally, the Auto Layout Cookbook presents a wide range of sample layouts of varying levels of complexity, you can study and use in your own projects, and Debugging Auto Layout offers advice and tools for fixing things if anything goes wrong.


这份指导剩下的文章旨在帮助你顺利地过渡到 `Auto Layout`。[The Auto Layout Without Constraints](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html#//apple_ref/doc/uid/TP40010853-CH8-SW1) 这章，描述了简化创造 `Auto Layout`  的高等级抽象





